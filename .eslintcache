[{"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\App.js":"1","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\index.js":"2","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\algorithms.js":"3","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Step2.js":"4","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Step3.js":"5","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Header.js":"6","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\theme.js":"7","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Step1.js":"8","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Footer.js":"9","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\utils.js":"10","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\CustomSlider.js":"11"},{"size":9000,"mtime":1608207612439,"results":"12","hashOfConfig":"13"},{"size":509,"mtime":1607707224058,"results":"14","hashOfConfig":"13"},{"size":12620,"mtime":1608194555355,"results":"15","hashOfConfig":"13"},{"size":5320,"mtime":1608194602039,"results":"16","hashOfConfig":"13"},{"size":1820,"mtime":1608194540586,"results":"17","hashOfConfig":"13"},{"size":358,"mtime":1606659611855,"results":"18","hashOfConfig":"13"},{"size":331,"mtime":1607514936039,"results":"19","hashOfConfig":"13"},{"size":3682,"mtime":1608194538514,"results":"20","hashOfConfig":"13"},{"size":266,"mtime":1606657679108,"results":"21","hashOfConfig":"13"},{"size":649,"mtime":1608208226718,"results":"22","hashOfConfig":"13"},{"size":575,"mtime":1608172989127,"results":"23","hashOfConfig":"13"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1qvfe1d",{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31"},{"filePath":"32","messages":"33","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"34","messages":"35","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"38"},{"filePath":"39","messages":"40","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"41"},{"filePath":"42","messages":"43","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"44","messages":"45","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"46"},{"filePath":"47","messages":"48","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\App.js",[],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\index.js",[],["51","52"],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\algorithms.js",["53","54"],"import { getLCM } from \"./utils\";\r\n\r\nexport const FCFS = (processes) =>\r\n  processes\r\n    .sort((a, b) =>\r\n      a.arrivalTime < b.arrivalTime ? -1 : a.arrivalTime > b.arrivalTime ? 1 : 0\r\n    )\r\n    .map((element, index, array) => {\r\n      element.startingTime = index =\r\n        index !== 0 && element.arrivalTime <= array[index - 1].completionTime\r\n          ? array[index - 1].completionTime\r\n          : element.arrivalTime;\r\n      element.completionTime = element.startingTime + element.burstTime;\r\n      element.turnAroundTime = element.completionTime - element.arrivalTime;\r\n      element.waitingTime = element.turnAroundTime - element.burstTime;\r\n      return element;\r\n    })\r\n    .sort((a, b) => (a.pid < b.pid ? -1 : a.pid > b.pid ? 1 : 0));\r\n\r\nexport const SJF = (processes) => {\r\n  let time = 0;\r\n  while (\r\n    processes.filter((element) => element.isDone === undefined).length > 0\r\n  ) {\r\n    let queue = processes.filter(\r\n      (element) => element.arrivalTime <= time && element.isDone === undefined\r\n    );\r\n    if (queue.length > 0) {\r\n      let currentProcess = queue.sort((a, b) =>\r\n        a.burstTime < b.burstTime\r\n          ? -1\r\n          : a.burstTime > b.burstTime\r\n          ? 1\r\n          : a.arrivalTime < b.arrivalTime\r\n          ? -1\r\n          : a.arrivalTime > b.arrivalTime\r\n          ? 1\r\n          : 0\r\n      )[0];\r\n      currentProcess.startingTime = time;\r\n      currentProcess.completionTime =\r\n        currentProcess.startingTime + currentProcess.burstTime;\r\n      currentProcess.turnAroundTime =\r\n        currentProcess.completionTime - currentProcess.arrivalTime;\r\n      currentProcess.waitingTime =\r\n        currentProcess.turnAroundTime - currentProcess.burstTime;\r\n      currentProcess.isDone = true;\r\n      time = currentProcess.completionTime;\r\n    } else time++;\r\n  }\r\n  return processes;\r\n};\r\n\r\nexport const PRIO = (processes) => {\r\n  let time = 0;\r\n  while (\r\n    processes.filter((element) => element.isDone === undefined).length > 0\r\n  ) {\r\n    let queue = processes.filter(\r\n      (element) => element.arrivalTime <= time && element.isDone === undefined\r\n    );\r\n    if (queue.length > 0) {\r\n      let currentProcess = queue.sort((a, b) =>\r\n        a.priorityNumber < b.priorityNumber\r\n          ? -1\r\n          : a.priorityNumber > b.priorityNumber\r\n          ? 1\r\n          : a.arrivalTime < b.arrivalTime\r\n          ? -1\r\n          : a.arrivalTime > b.arrivalTime\r\n          ? 1\r\n          : 0\r\n      )[0];\r\n      currentProcess.startingTime = time;\r\n      currentProcess.completionTime =\r\n        currentProcess.startingTime + currentProcess.burstTime;\r\n      currentProcess.turnAroundTime =\r\n        currentProcess.completionTime - currentProcess.arrivalTime;\r\n      currentProcess.waitingTime =\r\n        currentProcess.turnAroundTime - currentProcess.burstTime;\r\n      currentProcess.isDone = true;\r\n      time = currentProcess.completionTime;\r\n    } else time++;\r\n  }\r\n  return processes;\r\n};\r\n\r\nexport const EDF = (processes) => {\r\n  let lcm = getLCM(processes.map(({ period }) => period));\r\n  processes.map((element) => {\r\n    element.remainingCapacity = element.capacity;\r\n    element.currentDeadline = element.deadline;\r\n    element.currentPeriod = 0;\r\n    return element;\r\n  });\r\n  for (let time = 0; time < lcm; time++) {\r\n    let queue = processes.filter(\r\n      (element) =>\r\n        element.remainingCapacity > 0 &&\r\n        element.currentPeriod <= time &&\r\n        element.currentDeadline >= time\r\n    );\r\n    if (queue.length > 0) {\r\n      let currentProcess = queue.sort((a, b) =>\r\n        a.currentDeadline < b.currentDeadline\r\n          ? -1\r\n          : a.currentDeadline > b.currentDeadline\r\n          ? 1\r\n          : a.pid < b.pid\r\n          ? -1\r\n          : a.pid > b.pid\r\n          ? 1\r\n          : 0\r\n      )[0];\r\n      if (currentProcess.startingTime === undefined)\r\n        currentProcess.startingTime = time;\r\n      currentProcess.remainingCapacity--;\r\n      if (currentProcess.remainingCapacity === 0) {\r\n        currentProcess.currentPeriod += currentProcess.period;\r\n        currentProcess.currentDeadline += currentProcess.period;\r\n        currentProcess.remainingCapacity = currentProcess.capacity;\r\n        if (currentProcess.currentDeadline >= lcm)\r\n          currentProcess.completionTime = time + 1;\r\n      }\r\n    }\r\n  }\r\n  return processes;\r\n};\r\n\r\nexport const MLQ = (processes, mlqs) => {\r\n  let runningProcess;\r\n  processes.map((element) => {\r\n    element.timeOfNextEnqueue = element.arrivalTime;\r\n    element.burstLeft = element.burstTime;\r\n    return element;\r\n  });\r\n  for (\r\n    let time = 0;\r\n    processes.filter((element) => element.isDone === undefined).length > 0;\r\n    time++\r\n  ) {\r\n    let queue = processes.filter(\r\n      (element) =>\r\n        element.isDone === undefined && element.timeOfNextEnqueue <= time\r\n    );\r\n    queue = queue.filter(\r\n      (element) =>\r\n        element.assignedQueueNumber ===\r\n        Math.min.apply(\r\n          Math,\r\n          queue.map((element) => element.assignedQueueNumber)\r\n        )\r\n    );\r\n    if (queue.length > 0) {\r\n      let activeAlgorithm = mlqs[queue[0].assignedQueueNumber];\r\n\r\n      if (activeAlgorithm.mode === \"FCFS\") {\r\n        let electedProcess = queue.sort((a, b) =>\r\n          a.timeOfNextEnqueue < b.timeOfNextEnqueue\r\n            ? -1\r\n            : a.timeOfNextEnqueue > b.timeOfNextEnqueue\r\n            ? 1\r\n            : 0\r\n        )[0];\r\n        if (runningProcess === undefined) runningProcess = electedProcess;\r\n        if (runningProcess.pid !== electedProcess.pid) {\r\n          runningProcess.timeOfNextEnqueue = time + 1;\r\n          runningProcess = electedProcess;\r\n        }\r\n        if (runningProcess.startingTime === undefined)\r\n          runningProcess.startingTime = time;\r\n        runningProcess.burstLeft -= 1;\r\n        if (runningProcess.burstLeft === 0) {\r\n          runningProcess.completionTime = time + 1;\r\n          runningProcess.isDone = true;\r\n          runningProcess = () => {\r\n            return;\r\n          };\r\n          // modify code below . . .\r\n\r\n          // modify code above . . .\r\n        } else runningProcess.timeOfNextEnqueue = time + 1;\r\n      } else if (activeAlgorithm.mode === \"SJF\") {\r\n        let q = queue.sort((a, b) =>\r\n          a.burstTime < b.burstTime\r\n            ? -1\r\n            : a.burstTime > b.burstTime\r\n            ? 1\r\n            : a.timeOfNextEnqueue < b.timeOfNextEnqueue\r\n            ? -1\r\n            : a.timeOfNextEnqueue > b.timeOfNextEnqueue\r\n            ? 1\r\n            : 0\r\n        );\r\n        let electedProcess =\r\n          q.find((element) => element.isRunning === true) === undefined\r\n            ? q[0]\r\n            : q.find((element) => element.isRunning === true);\r\n        if (runningProcess === undefined) runningProcess = electedProcess;\r\n        if (runningProcess.pid !== electedProcess.pid) {\r\n          runningProcess.timeOfNextEnqueue = time + 1;\r\n          runningProcess = electedProcess;\r\n        }\r\n        if (runningProcess.startingTime === undefined)\r\n          runningProcess.startingTime = time;\r\n        if (runningProcess.isRunning === undefined)\r\n          runningProcess.isRunning = true;\r\n        runningProcess.burstLeft -= 1;\r\n        if (runningProcess.burstLeft === 0) {\r\n          runningProcess.completionTime = time + 1;\r\n          runningProcess.isDone = true;\r\n          runningProcess = () => {\r\n            return;\r\n          };\r\n          // modify code below . . .\r\n\r\n          // modify code above . . .\r\n        } else runningProcess.timeOfNextEnqueue = time + 1;\r\n      } else if (activeAlgorithm.mode === \"SRTF\") {\r\n        let q = queue.sort((a, b) =>\r\n          a.burstLeft < b.burstLeft\r\n            ? -1\r\n            : a.burstLeft > b.burstLeft\r\n            ? 1\r\n            : a.timeOfNextEnqueue < b.timeOfNextEnqueue\r\n            ? -1\r\n            : a.timeOfNextEnqueue > b.timeOfNextEnqueue\r\n            ? 1\r\n            : 0\r\n        );\r\n        if (runningProcess === undefined) runningProcess = q[0];\r\n        if (runningProcess.pid !== q[0].pid) {\r\n          runningProcess.timeOfNextEnqueue = time + 1;\r\n          runningProcess = q[0];\r\n        }\r\n        if (runningProcess.startingTime === undefined)\r\n          runningProcess.startingTime = time;\r\n        runningProcess.burstLeft -= 1;\r\n        if (runningProcess.burstLeft === 0) {\r\n          runningProcess.completionTime = time + 1;\r\n          runningProcess.isDone = true;\r\n          runningProcess = () => {\r\n            return;\r\n          };\r\n          // modify code below . . .\r\n\r\n          // modify code above . . .\r\n        } else runningProcess.timeOfNextEnqueue = time + 1;\r\n      } else if (activeAlgorithm.mode === \"PRIO\") {\r\n        let q = queue.sort((a, b) =>\r\n          a.priorityNumber < b.priorityNumber\r\n            ? -1\r\n            : a.priorityNumber > b.priorityNumber\r\n            ? 1\r\n            : a.timeOfNextEnqueue < b.timeOfNextEnqueue\r\n            ? -1\r\n            : a.timeOfNextEnqueue > b.timeOfNextEnqueue\r\n            ? 1\r\n            : 0\r\n        );\r\n        let electedProcess =\r\n          q.find((element) => element.isRunning === true) === undefined\r\n            ? q[0]\r\n            : q.find((element) => element.isRunning === true);\r\n        if (runningProcess === undefined) runningProcess = electedProcess;\r\n        if (runningProcess.pid !== electedProcess.pid) {\r\n          runningProcess.timeOfNextEnqueue = time + 1;\r\n          runningProcess = electedProcess;\r\n        }\r\n        if (runningProcess.startingTime === undefined)\r\n          runningProcess.startingTime = time;\r\n        if (runningProcess.isRunning === undefined)\r\n          runningProcess.isRunning = true;\r\n        runningProcess.burstLeft -= 1;\r\n        if (runningProcess.burstLeft === 0) {\r\n          runningProcess.completionTime = time + 1;\r\n          runningProcess.isDone = true;\r\n          runningProcess = () => {\r\n            return;\r\n          };\r\n          // modify code below . . .\r\n\r\n          // modify code above . . .\r\n        } else runningProcess.timeOfNextEnqueue = time + 1;\r\n      } else if (activeAlgorithm.mode === \"P-PRIO\") {\r\n        let q = queue.sort((a, b) =>\r\n          a.priorityNumber < b.priorityNumber\r\n            ? -1\r\n            : a.priorityNumber > b.priorityNumber\r\n            ? 1\r\n            : a.timeOfNextEnqueue < b.timeOfNextEnqueue\r\n            ? -1\r\n            : a.timeOfNextEnqueue > b.timeOfNextEnqueue\r\n            ? 1\r\n            : 0\r\n        );\r\n        if (runningProcess === undefined) runningProcess = q[0];\r\n        if (runningProcess.pid !== q[0].pid) {\r\n          runningProcess.timeOfNextEnqueue = time + 1;\r\n          runningProcess = q[0];\r\n        }\r\n        if (runningProcess.startingTime === undefined)\r\n          runningProcess.startingTime = time;\r\n        runningProcess.burstLeft -= 1;\r\n        if (runningProcess.burstLeft === 0) {\r\n          runningProcess.completionTime = time + 1;\r\n          runningProcess.isDone = true;\r\n          runningProcess = () => {\r\n            return;\r\n          };\r\n        } else runningProcess.timeOfNextEnqueue = time + 1;\r\n      } else if (activeAlgorithm.mode === \"RR\") {\r\n        let electedProcess = queue.sort((a, b) =>\r\n          a.timeOfNextEnqueue < b.timeOfNextEnqueue\r\n            ? -1\r\n            : a.timeOfNextEnqueue > b.timeOfNextEnqueue\r\n            ? 1\r\n            : 0\r\n        )[0];\r\n        if (runningProcess === undefined) runningProcess = electedProcess;\r\n        if (runningProcess.pid !== electedProcess.pid) {\r\n          runningProcess.timeOfNextEnqueue = time + 1;\r\n          runningProcess.quantumTimeLeft = activeAlgorithm.timeQuantum - 1;\r\n          runningProcess = electedProcess;\r\n        }\r\n        if (runningProcess.startingTime === undefined)\r\n          runningProcess.startingTime = time;\r\n        if (runningProcess.quantumTimeLeft === undefined)\r\n          runningProcess.quantumTimeLeft = activeAlgorithm.timeQuantum;\r\n        runningProcess.burstLeft -= 1;\r\n        runningProcess.quantumTimeLeft -= 1;\r\n        if (runningProcess.burstLeft === 0) {\r\n          runningProcess.completionTime = time + 1;\r\n          runningProcess.isDone = true;\r\n          runningProcess = () => {\r\n            return;\r\n          };\r\n          // modify code below . . .\r\n\r\n          // modify code above . . .\r\n        } else if (runningProcess.quantumTimeLeft === 0) {\r\n          runningProcess.quantumTimeLeft = activeAlgorithm.timeQuantum;\r\n          runningProcess.timeOfNextEnqueue = time + 1;\r\n        }\r\n      } else if (activeAlgorithm.mode === \"RRO\") {\r\n      }\r\n    }\r\n  }\r\n  return processes;\r\n};\r\n","C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Step2.js",[],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Step3.js",[],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Header.js",[],["55","56"],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\theme.js",[],["57","58"],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Step1.js",[],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\Footer.js",[],["59","60"],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\utils.js",[],"C:\\Users\\allen\\Desktop\\react-cpu-scheduling\\src\\components\\CustomSlider.js",[],{"ruleId":"61","replacedBy":"62"},{"ruleId":"63","replacedBy":"64"},{"ruleId":"65","severity":1,"message":"66","line":26,"column":7,"nodeType":"67","messageId":"68","endLine":26,"endColumn":79},{"ruleId":"65","severity":1,"message":"66","line":60,"column":7,"nodeType":"67","messageId":"68","endLine":60,"endColumn":79},{"ruleId":"61","replacedBy":"69"},{"ruleId":"63","replacedBy":"70"},{"ruleId":"61","replacedBy":"71"},{"ruleId":"63","replacedBy":"72"},{"ruleId":"61","replacedBy":"73"},{"ruleId":"63","replacedBy":"74"},"no-native-reassign",["75"],"no-negated-in-lhs",["76"],"no-loop-func","Function declared in a loop contains unsafe references to variable(s) 'time'.","ArrowFunctionExpression","unsafeRefs",["75"],["76"],["75"],["76"],["75"],["76"],"no-global-assign","no-unsafe-negation"]